### Прототипное наследование


Модель наследования в JavaScript может озадачить опытных разработчиков на высокоуровневых объектно-ориентированных языках (таких, например, как Java или C++), поскольку она динамическая и не включает в себя реализацию понятия class (хотя ключевое слово class, бывшее долгие годы зарезервированным, и приобрело практическое значение в стандарте ES2015, однако, классы в JavaScript представляют собой лишь "синтаксический сахар" поверх прототипно-ориентированной модели наследования).


В плане наследования JavaScript работает лишь с одной сущностью: объектами. Каждый объект имеет внутреннюю ссылку на другой объект, называемый его прототипом. У объекта-прототипа также есть свой собственный прототип и так далее до тех пор, пока цепочка не завершится объектом, у которого свойство prototype равно null. По определению, null не имеет прототипа и является завершающим звеном в цепочке прототипов.


Хотя прототипную модель наследования некоторые относят к недостаткам JavaScript, на самом деле она мощнее классической. К примеру, поверх неё можно предельно просто реализовать классическое наследование, а вот попытки совершить обратное непременно вынудят вас попотеть.
```javascript
let animal = {
 eats: true,
 walk() {
   /* этот метод не будет использоваться в rabbit */
 },
};
let rabbit = {
 __proto__: animal,
};


rabbit.walk = function () {
 console.log("Rabbit! Bounce-bounce!");
};


rabbit.walk(); // Rabbit! Bounce-bounce!
```






### Объект:


Объект в JavaScript - это составной тип данных, представленный коллекцией ключ-значение. Ключи (также называемые свойствами) являются строками или символами, а значения могут быть любыми типами данных, включая другие объекты.


```javascript
const person = {
  name: 'John',
  age: 25,
  sayHello: function() {
    console.log(`Hello, my name is ${this.name}.`);
  }
};
```


### `this` и Контекст:


Ключевое слово `this` в JavaScript используется для обращения к текущему объекту. Контекст `this` зависит от того, как вызывается функция.


```javascript
const person = {
  name: 'John',
  introduce: function() {
    console.log(`Hello, my name is ${this.name}.`);
  }
};


person.introduce(); // "Hello, my name is John."
```


### Глобальный Объект, Текущий Объект:


- **Глобальный объект:** В браузере это объект `window`, в Node.js - `global`. Содержит глобальные переменные и функции.
- **Текущий объект:** Это объект, к которому относится текущий контекст выполнения. В глобальной области видимости это глобальный объект.


### `call`, `apply`, `bind`:


- **`call` и `apply`:** Методы используются для вызова функции с указанием конкретного объекта в качестве `this`. Разница между ними в передаче аргументов - `call` передает аргументы по одному, `apply` передает массив аргументов.
  ```javascript
  function greet(message) {
    console.log(`${message}, ${this.name}.`);
  }


  const person = { name: 'John' };
  greet.call(person, 'Hello'); // "Hello, John."
  greet.apply(person, ['Hi']); // "Hi, John."
  ```


- **`bind`:** Метод создает новую функцию, привязывая указанный объект к `this` внутри функции.
  ```javascript
  const greetPerson = greet.bind(person);
  greetPerson('Hola'); // "Hola, John."
  ```


### Методы `Object`:


- **`getPrototypeOf` и `setPrototypeOf`:** Методы используются для получения и установки прототипа объекта.
  ```javascript
  const parent = { parentProp: 'I am the parent.' };
  const child = { childProp: 'I am the child.' };


  Object.setPrototypeOf(child, parent);
  console.log(Object.getPrototypeOf(child)); // parent object
  ```


- **`assign`:** Метод используется для копирования значений всех перечислимых свойств одного или нескольких исходных объектов в целевой объект.
  ```javascript
  const obj1 = { a: 1, b: 2 };
  const obj2 = { b: 3, c: 4 };
  const mergedObj = Object.assign({}, obj1, obj2);
  // mergedObj: { a: 1, b: 3, c: 4 }
  ```


Эти концепции и методы предоставляют мощные инструменты для работы с объектами и наследованием в JavaScript.